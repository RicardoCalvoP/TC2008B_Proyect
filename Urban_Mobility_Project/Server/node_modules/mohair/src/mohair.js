// Generated by CoffeeScript 1.6.3
var actions, criterion, rawPrototype,
  __slice = [].slice;

criterion = require('criterion');

actions = require('./actions');

rawPrototype = {
  sql: function() {
    return this._sql;
  },
  params: function() {
    return this._params;
  }
};

module.exports = {
  raw: function() {
    var object, params, sql;
    sql = arguments[0], params = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    object = Object.create(rawPrototype);
    object._sql = sql;
    object._params = params;
    return object;
  },
  fluent: function(key, value) {
    var object;
    object = Object.create(this);
    object[key] = value;
    return object;
  },
  _escape: function(string) {
    return string;
  },
  _action: actions.select('*'),
  _joins: [],
  insert: function(data) {
    if ('object' !== typeof data) {
      throw new Error('data argument must be an object');
    }
    return this.fluent('_action', actions.insert(data));
  },
  insertMany: function(array) {
    var keysOfFirstRecord, msg;
    if (!Array.isArray(array)) {
      throw new Error('array argument must be an array');
    }
    if (array.length === 0) {
      throw new Error('array argument is empty - no records to insert');
    }
    msg = 'all records in the argument array must have the same keys.';
    keysOfFirstRecord = Object.keys(array[0]);
    array.forEach(function(data) {
      var keys;
      keys = Object.keys(data);
      if (keys.length !== keysOfFirstRecord.length) {
        throw new Error(msg);
      }
      return keysOfFirstRecord.forEach(function(key) {
        if (data[key] == null) {
          throw new Error(msg);
        }
      });
    });
    return this.fluent('_action', actions.insertMany(array));
  },
  escape: function(arg) {
    return this.fluent('_escape', arg);
  },
  select: function() {
    return this.fluent('_action', actions.select.apply(null, arguments));
  },
  "delete": function() {
    return this.fluent('_action', actions["delete"]());
  },
  update: function(updates) {
    return this.fluent('_action', actions.update(updates));
  },
  join: function() {
    var criterionArgs, join, object, sql;
    sql = arguments[0], criterionArgs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    join = {
      sql: sql
    };
    if (criterionArgs.length !== 0) {
      join.criterion = criterion.apply(null, criterionArgs);
    }
    object = Object.create(this);
    object._joins = this._joins.slice();
    object._joins.push(join);
    return object;
  },
  "with": function(arg) {
    if (!(('object' === typeof arg) && Object.keys(arg).length !== 0)) {
      throw new Error('with must be called with an object that has at least one property');
    }
    return this.fluent('_with', arg);
  },
  group: function(arg) {
    return this.fluent('_group', arg);
  },
  order: function(arg) {
    return this.fluent('_order', arg);
  },
  limit: function(arg) {
    return this.fluent('_limit', parseInt(arg, 10));
  },
  offset: function(arg) {
    return this.fluent('_offset', parseInt(arg, 10));
  },
  table: function(table) {
    return this.fluent('_table', table);
  },
  where: function() {
    var args, where;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    where = criterion.apply(null, args);
    return this.fluent('_where', this._where != null ? this._where.and(where) : where);
  },
  sql: function() {
    return this._action.sql(this);
  },
  params: function() {
    return this._action.params(this);
  }
};
